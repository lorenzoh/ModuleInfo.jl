{"attributes":{"kind":"struct","backlinks":[],"methods":[{"symbol_id":"StructTypes.DictType","module_id":"StructTypes","file":"StructTypes.jl","line":353,"signature":"(::Signature)"}],"package_id":"StructTypes@1.10.0","title":"DictType","symbol_id":"StructTypes.DictType","exported":false,"module_id":"StructTypes"},"tag":"documentation","children":[{"attributes":{"symbol":"StructTypes.DictType","line":331,"module":"StructTypes","file":"StructTypes.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["StructTypes.StructType(::Type{T}) = StructTypes.DictType()\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Declare that ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," should map to a dict-like object of unordered key-value pairs, where keys are ",{"attributes":{},"tag":"code","children":["Symbol"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["String"],"type":"node"},", or ",{"attributes":{},"tag":"code","children":["Int64"],"type":"node"},", and values are any other type (or ",{"attributes":{},"tag":"code","children":["Any"],"type":"node"},")."],"type":"node"},{"attributes":{},"tag":"p","children":["Types already declared as ",{"attributes":{},"tag":"code","children":["StructTypes.DictType()"],"type":"node"}," include:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any subtype of ",{"attributes":{},"tag":"code","children":["AbstractDict"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any ",{"attributes":{},"tag":"code","children":["NamedTuple"],"type":"node"}," type"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["The ",{"attributes":{},"tag":"code","children":["Pair"],"type":"node"}," type"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["So if your type subtypes ",{"attributes":{},"tag":"code","children":["AbstractDict"],"type":"node"}," and implements its interface, then it will inherit the ",{"attributes":{},"tag":"code","children":["DictType"],"type":"node"}," definition and serializing/deserializing should work automatically."],"type":"node"},{"attributes":{},"tag":"p","children":["Otherwise, the interface to satisfy ",{"attributes":{},"tag":"code","children":["StructTypes.DictType()"],"type":"node"}," for deserializing is:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["T(x::Dict{Symbol, Any})"],"type":"node"},": implement a constructor that takes a ",{"attributes":{},"tag":"code","children":["Dict{Symbol, Any}"],"type":"node"}," of input key-value pairs"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["StructTypes.construct(::Type{T}, x::Dict; kw...)"],"type":"node"},": alternatively, you may overload the ",{"attributes":{},"tag":"code","children":["StructTypes.construct"],"type":"node"}," method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The interface to satisfy for serializing is:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["pairs(x)"],"type":"node"},": implement the ",{"attributes":{},"tag":"code","children":["pairs"],"type":"node"}," iteration function (from Base) to iterate key-value pairs to be serialized"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["StructTypes.keyvaluepairs(x::T)"],"type":"node"},": alternatively, you can overload the ",{"attributes":{},"tag":"code","children":["StructTypes.keyvaluepairs"],"type":"node"}," function if overloading ",{"attributes":{},"tag":"code","children":["pairs"],"type":"node"}," isn't possible for whatever reason"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}