{"attributes":{"kind":"abstract type","backlinks":[],"methods":[{"symbol_id":"StructTypes.Struct","module_id":"StructTypes","file":"StructTypes.jl","line":115,"signature":"(::Signature)"}],"package_id":"StructTypes@1.10.0","title":"Struct","symbol_id":"StructTypes.Struct","exported":false,"module_id":"StructTypes"},"tag":"documentation","children":[{"attributes":{"symbol":"StructTypes.Struct","line":63,"module":"StructTypes","file":"StructTypes.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["StructTypes.StructType(::Type{T}) = StructTypes.Struct()\nStructTypes.StructType(::Type{T}) = StructTypes.UnorderedStruct()\nStructTypes.StructType(::Type{T}) = StructTypes.OrderedStruct()\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Signal that ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," is an immutable type who's fields should be used directly when serializing/deserializing. If a type is defined as ",{"attributes":{},"tag":"code","children":["StructTypes.Struct"],"type":"node"},", it defaults to ",{"attributes":{},"tag":"code","children":["StructTypes.UnorderedStruct"],"type":"node"},", which means its fields are allowed to be serialized/deserialized in any order, as opposed to ",{"attributes":{},"tag":"code","children":["StructTypes.OrderedStruct"],"type":"node"}," which signals that serialization/deserialization ",{"attributes":{},"tag":"em","children":["must"],"type":"node"}," occur in its defined field order exclusively. This can enable optimizations when an order can be guaranteed, but care must be taken to ensure any serialization formats can properly guarantee the order (for example, the JSON specification doesn't explicitly require ordered fields for \"objects\", though most implementations have a way to support this)."],"type":"node"},{"attributes":{},"tag":"p","children":["For ",{"attributes":{},"tag":"code","children":["StructTypes.UnorderedStruct"],"type":"node"},", if a field is missing from the serialization, ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"}," should be passed to the ",{"attributes":{},"tag":"code","children":["StructTypes.construct"],"type":"node"}," method."],"type":"node"},{"attributes":{},"tag":"p","children":["For example, when deserializing a ",{"attributes":{},"tag":"code","children":["Struct.OrderedStruct"],"type":"node"},", parsed input fields are passed directly, in input order to the ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," constructor, like ",{"attributes":{},"tag":"code","children":["T(field1, field2, field3)"],"type":"node"},". This means that field names may be ignored when deserializing; fields are directly passed to ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," in the order they're encountered."],"type":"node"},{"attributes":{},"tag":"p","children":["Another example, for reading a ",{"attributes":{},"tag":"code","children":["StructTypes.OrderedStruct()"],"type":"node"}," from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like ",{"attributes":{},"tag":"code","children":["T(val1, val2, val3)"],"type":"node"},". Yes, the JSON specification says that Objects are specifically ",{"attributes":{},"tag":"strong","children":["un-ordered"],"type":"node"}," collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the \"trusting\" that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of ",{"attributes":{},"tag":"code","children":["StructTypes.OrderedStruct()"],"type":"node"}," in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren't anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the ",{"attributes":{},"tag":"code","children":["StructTypes.UnorderedStruct"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["StructTypes.Mutable()"],"type":"node"}," options."],"type":"node"},{"attributes":{"lang":"@example"},"tag":"codeblock","children":["struct CoolType\n    val1::Int\n    val2::Int\n    val3::String\nend\n\nStructTypes.StructType(::Type{CoolType}) = StructTypes.OrderedStruct()\n\n# JSON3 package as example\n@assert JSON3.read(\"{\"val1\": 1, \"val2\": 2, \"val3\": 3}\", CoolType) == CoolType(1, 2, \"3\")\n# note how `val2` field is first, then `val1`, but fields are passed *in-order* to `CoolType` constructor; BE CAREFUL!\n@assert JSON3.read(\"{\"val2\": 2, \"val1\": 1, \"val3\": 3}\", CoolType) == CoolType(2, 1, \"3\")\n# if we instead define `Struct`, which defaults to `StructTypes.UnorderedStruct`, then the above example works\nStructTypes.StructType(::Type{CoolType}) = StructTypes.Struct()\n@assert JSON3.read(\"{\"val2\": 2, \"val1\": 1, \"val3\": 3}\", CoolType) == CoolType(1, 2, \"3\")\n"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}