{"attributes":{"kind":"function","backlinks":[],"methods":[{"symbol_id":"StructTypes.foreachfield","module_id":"StructTypes","file":"StructTypes.jl","line":714,"signature":"(::Signature)"},{"symbol_id":"StructTypes.foreachfield","module_id":"StructTypes","file":"StructTypes.jl","line":661,"signature":"(::Signature)"}],"package_id":"StructTypes@1.10.0","title":"foreachfield","symbol_id":"StructTypes.foreachfield","exported":false,"module_id":"StructTypes"},"tag":"documentation","children":[{"attributes":{"symbol":"StructTypes.foreachfield","line":648,"module":"StructTypes","file":"StructTypes.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["StructTypes.foreachfield(f, x::T) => Nothing\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Apply function ",{"attributes":{},"tag":"code","children":["f(i, name, FT, v; kw...)"],"type":"node"}," over each field index ",{"attributes":{},"tag":"code","children":["i"],"type":"node"},", field name ",{"attributes":{},"tag":"code","children":["name"],"type":"node"},", field type ",{"attributes":{},"tag":"code","children":["FT"],"type":"node"},", field value ",{"attributes":{},"tag":"code","children":["v"],"type":"node"},", and any ",{"attributes":{},"tag":"code","children":["kw"],"type":"node"}," keyword arguments defined in ",{"attributes":{},"tag":"code","children":["StructTypes.keywordargs"],"type":"node"}," for ",{"attributes":{},"tag":"code","children":["name"],"type":"node"}," in ",{"attributes":{},"tag":"code","children":["x"],"type":"node"},". Nothing is returned and results from ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," are ignored. Similar to ",{"attributes":{},"tag":"code","children":["Base.foreach"],"type":"node"}," over collections."],"type":"node"},{"attributes":{},"tag":"p","children":["Various \"configurations\" are respected when applying ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," to each field:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If keyword arguments have been defined for a field via ",{"attributes":{},"tag":"code","children":["StructTypes.keywordargs"],"type":"node"},", they will be passed like ",{"attributes":{},"tag":"code","children":["f(i, name, FT, v; kw...)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["StructTypes.names"],"type":"node"}," has been defined, ",{"attributes":{},"tag":"code","children":["name"],"type":"node"}," will be the serialization name instead of the defined julia field name"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If a field is undefined or empty and ",{"attributes":{},"tag":"code","children":["StructTypes.omitempties"],"type":"node"}," is defined, ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," won't be applied to that field"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If a field has been excluded via ",{"attributes":{},"tag":"code","children":["StructTypes.excludes"],"type":"node"},", it will be skipped"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{"symbol":"StructTypes.foreachfield","line":702,"module":"StructTypes","file":"StructTypes.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["StructTypes.foreachfield(f, T) => Nothing\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Apply function ",{"attributes":{},"tag":"code","children":["f(i, name, FT; kw...)"],"type":"node"}," over each field index ",{"attributes":{},"tag":"code","children":["i"],"type":"node"},", field name ",{"attributes":{},"tag":"code","children":["name"],"type":"node"},", field type ",{"attributes":{},"tag":"code","children":["FT"],"type":"node"},", and any ",{"attributes":{},"tag":"code","children":["kw"],"type":"node"}," keyword arguments defined in ",{"attributes":{},"tag":"code","children":["StructTypes.keywordargs"],"type":"node"}," for ",{"attributes":{},"tag":"code","children":["name"],"type":"node"}," on type ",{"attributes":{},"tag":"code","children":["T"],"type":"node"},". Nothing is returned and results from ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," are ignored. Similar to ",{"attributes":{},"tag":"code","children":["Base.foreach"],"type":"node"}," over collections."],"type":"node"},{"attributes":{},"tag":"p","children":["Various \"configurations\" are respected when applying ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," to each field:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If keyword arguments have been defined for a field via ",{"attributes":{},"tag":"code","children":["StructTypes.keywordargs"],"type":"node"},", they will be passed like ",{"attributes":{},"tag":"code","children":["f(i, name, FT, v; kw...)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["StructTypes.names"],"type":"node"}," has been defined, ",{"attributes":{},"tag":"code","children":["name"],"type":"node"}," will be the serialization name instead of the defined julia field name"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If a field has been excluded via ",{"attributes":{},"tag":"code","children":["StructTypes.excludes"],"type":"node"},", it will be skipped"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}