{"attributes":{"kind":"struct","backlinks":[],"methods":[{"symbol_id":"StructTypes.Mutable","module_id":"StructTypes","file":"StructTypes.jl","line":150,"signature":"(::Signature)"}],"package_id":"StructTypes@1.10.0","title":"Mutable","symbol_id":"StructTypes.Mutable","exported":false,"module_id":"StructTypes"},"tag":"documentation","children":[{"attributes":{"symbol":"StructTypes.Mutable","line":121,"module":"StructTypes","file":"StructTypes.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["StructTypes.StructType(::Type{T}) = StructTypes.Mutable()\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Signal that ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," is a mutable struct with an empty constructor for serializing/deserializing. Though slightly less performant than ",{"attributes":{},"tag":"code","children":["StructTypes.Struct"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["Mutable"],"type":"node"}," is a much more robust method for mapping Julia struct fields for serialization. This technique requires your Julia type to be defined, ",{"attributes":{},"tag":"strong","children":["at a minimum"],"type":"node"},", like:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"struct","children":[{"attributes":{},"tag":"mutable","children":["mutable"],"type":"node"},{"attributes":{},"tag":"true","children":[""],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"struct","children":["struct"],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"Identifier","children":["T"],"type":"node"},{"attributes":{},"tag":"block","children":[{"attributes":{},"tag":"NewlineWs","children":["\n    "],"type":"node"},{"attributes":{},"tag":"Identifier","children":["field1"],"type":"node"},{"attributes":{},"tag":"NewlineWs","children":["\n    "],"type":"node"},{"attributes":{},"tag":"Identifier","children":["field2"],"type":"node"},{"attributes":{},"tag":"NewlineWs","children":["\n    "],"type":"node"},{"attributes":{},"tag":"Identifier","children":["field3"],"type":"node"},{"attributes":{},"tag":"NewlineWs","children":["\n    "],"type":"node"},{"attributes":{},"tag":"Comment","children":["# etc."],"type":"node"},{"attributes":{},"tag":"NewlineWs","children":["\n"],"type":"node"},{"attributes":{},"tag":"NewlineWs","children":["\n    "],"type":"node"},{"attributes":{},"tag":"=","children":[{"attributes":{},"tag":"call","children":[{"attributes":{},"tag":"Identifier","children":["T"],"type":"node"},{"attributes":{},"tag":"(","children":["("],"type":"node"},{"attributes":{},"tag":")","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"=","children":["="],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"call","children":[{"attributes":{},"tag":"Identifier","children":["new"],"type":"node"},{"attributes":{},"tag":"(","children":["("],"type":"node"},{"attributes":{},"tag":")","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NewlineWs","children":["\n"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"end","children":["end"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Note specifically that we're defining a ",{"attributes":{},"tag":"code","children":["mutable struct"],"type":"node"}," to allow field mutation, and providing a ",{"attributes":{},"tag":"code","children":["T() = new()"],"type":"node"}," inner constructor which constructs an \"empty\" ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," where ",{"attributes":{},"tag":"code","children":["isbitstype"],"type":"node"}," fields will be randomly initialized, and reference fields will be ",{"attributes":{},"tag":"code","children":["#undef"],"type":"node"},". (Note that the inner constructor doesn't need to be ",{"attributes":{},"tag":"strong","children":["exactly"],"type":"node"}," this, but at least needs to be callable like ",{"attributes":{},"tag":"code","children":["T()"],"type":"node"},". If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initialized like ",{"attributes":{},"tag":"code","children":["T()"],"type":"node"},", then serialization will take each key-value input pair, setting the field as the key is encountered, and converting the value to the appropriate field value. This flow has the nice properties of: allowing object construction success even if fields are missing in the input, and if \"extra\" fields exist in the input that aren't apart of the Julia struct's fields, they will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary data foramts that may be generated via web services, databases, other language libraries, etc."],"type":"node"},{"attributes":{},"tag":"p","children":["There are a few additional helper methods that can be utilized by ",{"attributes":{},"tag":"code","children":["StructTypes.Mutable()"],"type":"node"}," types to hand-tune field reading/writing behavior:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["StructTypes.names(::Type{T}) = ((:juliafield1, :serializedfield1), (:juliafield2, :serializedfield2))"],"type":"node"},": provides a mapping of Julia field name to expected serialized object key name. This affects both serializing and deserializing. When deserializing the ",{"attributes":{},"tag":"code","children":["serializedfield1"],"type":"node"}," key, the ",{"attributes":{},"tag":"code","children":["juliafield1"],"type":"node"}," field of ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," will be set. When serializing the ",{"attributes":{},"tag":"code","children":["juliafield2"],"type":"node"}," field of ",{"attributes":{},"tag":"code","children":["T"],"type":"node"},", the output key will be ",{"attributes":{},"tag":"code","children":["serializedfield2"],"type":"node"},". Field name mappings are provided as a ",{"attributes":{},"tag":"code","children":["Tuple"],"type":"node"}," of ",{"attributes":{},"tag":"code","children":["Tuple{Symbol, Symbol}"],"type":"node"},"s, i.e. each field mapping is a Julia field name ",{"attributes":{},"tag":"code","children":["Symbol"],"type":"node"}," (first) and serialized field name ",{"attributes":{},"tag":"code","children":["Symbol"],"type":"node"}," (second)."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["StructTypes.excludes(::Type{T}) = (:field1, :field2)"],"type":"node"},": specify fields of ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," to ignore when serializing and deserializing, provided as a ",{"attributes":{},"tag":"code","children":["Tuple"],"type":"node"}," of ",{"attributes":{},"tag":"code","children":["Symbol"],"type":"node"},"s. When deserializing, if ",{"attributes":{},"tag":"code","children":["field1"],"type":"node"}," is encountered as an input key, it's value will be read, but the field will not be set in ",{"attributes":{},"tag":"code","children":["T"],"type":"node"},". When serializing, ",{"attributes":{},"tag":"code","children":["field1"],"type":"node"}," will be skipped when serializing out ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," fields as key-value pairs."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["StructTypes.omitempties(::Type{T}) = (:field1, :field2)"],"type":"node"},": specify fields of ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," that shouldn't be serialized if they are \"empty\", provided as a ",{"attributes":{},"tag":"code","children":["Tuple"],"type":"node"}," of ",{"attributes":{},"tag":"code","children":["Symbol"],"type":"node"},"s. This only affects serializing. If a field is a collection (AbstractDict, AbstractArray, etc.) and ",{"attributes":{},"tag":"code","children":["isempty(x) === true"],"type":"node"},", then it will not be serialized. If a field is ",{"attributes":{},"tag":"code","children":["#undef"],"type":"node"},", it will not be serialized. If a field is ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"},", it will not be serialized. To apply this to all fields of ",{"attributes":{},"tag":"code","children":["T"],"type":"node"},", set ",{"attributes":{},"tag":"code","children":["StructTypes.omitempties(::Type{T}) = true"],"type":"node"},". You can customize this behavior. For example, by default, ",{"attributes":{},"tag":"code","children":["missing"],"type":"node"}," is not considered to be \"empty\". If you want ",{"attributes":{},"tag":"code","children":["missing"],"type":"node"}," to be considered \"empty\" when serializing your type ",{"attributes":{},"tag":"code","children":["MyType"],"type":"node"},", simply define:"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"macrocall","children":[{"attributes":{},"tag":"@","children":["@"],"type":"node"},{"attributes":{},"tag":"MacroName","children":["inline"],"type":"node"},{"attributes":{},"tag":"=","children":[{"attributes":{},"tag":"where","children":[{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"call","children":[{"attributes":{},"tag":".","children":[{"attributes":{"reftype":"symbol","document_id":"StructTypes@1.10.0/ref/StructTypes"},"tag":"reference","children":["StructTypes"],"type":"node"},{"attributes":{},"tag":".","children":["."],"type":"node"},{"attributes":{},"tag":"quote","children":[{"attributes":{"reftype":"symbol","document_id":"StructTypes@1.10.0/ref/StructTypes.isempty"},"tag":"reference","children":["isempty"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"(","children":["("],"type":"node"},{"attributes":{},"tag":"::","children":[{"attributes":{},"tag":"::","children":["::"],"type":"node"},{"attributes":{},"tag":"curly","children":[{"attributes":{},"tag":"Identifier","children":["Type"],"type":"node"},{"attributes":{},"tag":"{","children":["{"],"type":"node"},{"attributes":{},"tag":"Identifier","children":["T"],"type":"node"},{"attributes":{},"tag":"}","children":["}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":",","children":[","],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"::","children":[{"attributes":{},"tag":"::","children":["::"],"type":"node"},{"attributes":{},"tag":"Identifier","children":["Missing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":")","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"where","children":["where"],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"{","children":["{"],"type":"node"},{"attributes":{},"tag":"<:","children":[{"attributes":{},"tag":"Identifier","children":["T"],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"<:","children":["<:"],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"Identifier","children":["MyType"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"}","children":["}"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"=","children":["="],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"true","children":["true"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["StructTypes.keywordargs(::Type{T}) = (field1=(dateformat=dateformat\"mm/dd/yyyy\",), field2=(dateformat=dateformat\"HH MM SS\",))"],"type":"node"},": provide keyword arguments for fields of type ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," that should be passed to functions that set values for this field. Define ",{"attributes":{},"tag":"code","children":["StructTypes.keywordargs"],"type":"node"}," as a NamedTuple of NamedTuples."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}