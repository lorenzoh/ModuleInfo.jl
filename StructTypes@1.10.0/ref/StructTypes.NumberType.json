{"attributes":{"kind":"struct","backlinks":[],"methods":[{"symbol_id":"StructTypes.NumberType","module_id":"StructTypes","file":"StructTypes.jl","line":479,"signature":"(::Signature)"}],"package_id":"StructTypes@1.10.0","title":"NumberType","symbol_id":"StructTypes.NumberType","exported":false,"module_id":"StructTypes"},"tag":"documentation","children":[{"attributes":{"symbol":"StructTypes.NumberType","line":460,"module":"StructTypes","file":"StructTypes.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["StructTypes.StructType(::Type{T}) = StructTypes.NumberType()\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Declare that ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," should map to a number value."],"type":"node"},{"attributes":{},"tag":"p","children":["Types already declared as ",{"attributes":{},"tag":"code","children":["StructTypes.NumberType()"],"type":"node"}," include:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any subtype of ",{"attributes":{},"tag":"code","children":["Signed"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any subtype of ",{"attributes":{},"tag":"code","children":["Unsigned"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any subtype of ",{"attributes":{},"tag":"code","children":["AbstractFloat"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["In addition to declaring ",{"attributes":{},"tag":"code","children":["StructTypes.NumberType()"],"type":"node"},", custom types can also specify a specific, ",{"attributes":{},"tag":"strong","children":["existing"],"type":"node"}," number type it should map to. It does this like:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"=","children":[{"attributes":{},"tag":"call","children":[{"attributes":{},"tag":".","children":[{"attributes":{},"tag":"Identifier","children":["StructTypes"],"type":"node"},{"attributes":{},"tag":".","children":["."],"type":"node"},{"attributes":{},"tag":"quote","children":[{"attributes":{},"tag":"Identifier","children":["numbertype"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"(","children":["("],"type":"node"},{"attributes":{},"tag":"::","children":[{"attributes":{},"tag":"::","children":["::"],"type":"node"},{"attributes":{},"tag":"curly","children":[{"attributes":{},"tag":"Identifier","children":["Type"],"type":"node"},{"attributes":{},"tag":"{","children":["{"],"type":"node"},{"attributes":{},"tag":"Identifier","children":["T"],"type":"node"},{"attributes":{},"tag":"}","children":["}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":")","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"=","children":["="],"type":"node"},{"attributes":{},"tag":"Whitespace","children":[" "],"type":"node"},{"attributes":{},"tag":"Identifier","children":["Float64"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["In this case, ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," declares it should map to an already-supported number type: ",{"attributes":{},"tag":"code","children":["Float64"],"type":"node"},". This means that when deserializing, an input will be parsed/read/deserialiezd as a ",{"attributes":{},"tag":"code","children":["Float64"],"type":"node"}," value, and then call ",{"attributes":{},"tag":"code","children":["T(x::Float64)"],"type":"node"},". Note that custom types may also overload ",{"attributes":{},"tag":"code","children":["StructTypes.construct(::Type{T}, x::Float64; kw...)"],"type":"node"}," if using a constructor isn't possible. Also note that the default for any type declared as ",{"attributes":{},"tag":"code","children":["StructTypes.NumberType()"],"type":"node"}," is ",{"attributes":{},"tag":"code","children":["Float64"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["Similarly for serializing, ",{"attributes":{},"tag":"code","children":["Float64(x::T)"],"type":"node"}," will first be called before serializing the resulting ",{"attributes":{},"tag":"code","children":["Float64"],"type":"node"}," value."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}