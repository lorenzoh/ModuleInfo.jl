{"attributes":{"kind":"struct","backlinks":[],"methods":[{"symbol_id":"StructTypes.ArrayType","module_id":"StructTypes","file":"StructTypes.jl","line":387,"signature":"(::Signature)"}],"package_id":"StructTypes@1.10.0","title":"ArrayType","symbol_id":"StructTypes.ArrayType","exported":false,"module_id":"StructTypes"},"tag":"documentation","children":[{"attributes":{"symbol":"StructTypes.ArrayType","line":365,"module":"StructTypes","file":"StructTypes.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["StructTypes.StructType(::Type{T}) = StructTypes.ArrayType()\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Declare that ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," should map to an array of ordered elements, homogenous or otherwise."],"type":"node"},{"attributes":{},"tag":"p","children":["Types already declared as ",{"attributes":{},"tag":"code","children":["StructTypes.ArrayType()"],"type":"node"}," include:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any subtype of ",{"attributes":{},"tag":"code","children":["AbstractArray"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any subtype of ",{"attributes":{},"tag":"code","children":["AbstractSet"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any ",{"attributes":{},"tag":"code","children":["Tuple"],"type":"node"}," type"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["So if your type already subtypes these and satifies their interface, things should just work."],"type":"node"},{"attributes":{},"tag":"p","children":["Otherwise, the interface to satisfy ",{"attributes":{},"tag":"code","children":["StructTypes.ArrayType()"],"type":"node"}," for deserializing is:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["T(x::Vector)"],"type":"node"},": implement a constructor that takes a ",{"attributes":{},"tag":"code","children":["Vector"],"type":"node"}," argument of values and constructs a ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["StructTypes.construct(::Type{T}, x::Vector; kw...)"],"type":"node"},": alternatively, you may overload the ",{"attributes":{},"tag":"code","children":["StructTypes.construct"],"type":"node"}," method for your type if defining a constructor isn't possible"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Optional: ",{"attributes":{},"tag":"code","children":["Base.IteratorEltype(::Type{T}) = Base.HasEltype()"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["Base.eltype(x::T)"],"type":"node"},": this can be used to signal that elements for your type are expected to be a homogenous type"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The interface to satisfy for serializing is:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["iterate(x::T)"],"type":"node"},": just iteration over each element is required; note if you subtype ",{"attributes":{},"tag":"code","children":["AbstractArray"],"type":"node"}," and define ",{"attributes":{},"tag":"code","children":["getindex(x::T, i::Int)"],"type":"node"},", then iteration is inherited for your type"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}