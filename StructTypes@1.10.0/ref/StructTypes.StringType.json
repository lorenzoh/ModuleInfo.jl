{"attributes":{"kind":"struct","backlinks":[],"methods":[{"symbol_id":"StructTypes.StringType","module_id":"StructTypes","file":"StructTypes.jl","line":418,"signature":"(::Signature)"}],"package_id":"StructTypes@1.10.0","title":"StringType","symbol_id":"StructTypes.StringType","exported":false,"module_id":"StructTypes"},"tag":"documentation","children":[{"attributes":{"symbol":"StructTypes.StringType","line":393,"module":"StructTypes","file":"StructTypes.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["StructTypes.StructType(::Type{T}) = StructTypes.StringType()\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Declare that ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," should map to a string value."],"type":"node"},{"attributes":{},"tag":"p","children":["Types already declared as ",{"attributes":{},"tag":"code","children":["StructTypes.StringType()"],"type":"node"}," include:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any subtype of ",{"attributes":{},"tag":"code","children":["AbstractString"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["The ",{"attributes":{},"tag":"code","children":["Symbol"],"type":"node"}," type"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any subtype of ",{"attributes":{},"tag":"code","children":["Enum"],"type":"node"}," (values are written with their symbolic name)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any subtype of ",{"attributes":{},"tag":"code","children":["AbstractChar"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["The ",{"attributes":{},"tag":"code","children":["UUID"],"type":"node"}," type"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Any ",{"attributes":{},"tag":"code","children":["Dates.TimeType"],"type":"node"}," subtype (",{"attributes":{},"tag":"code","children":["Date"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["DateTime"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["Time"],"type":"node"},", etc.)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["So if your type is an ",{"attributes":{},"tag":"code","children":["AbstractString"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["Enum"],"type":"node"},", then things should already work."],"type":"node"},{"attributes":{},"tag":"p","children":["Otherwise, the interface to satisfy ",{"attributes":{},"tag":"code","children":["StructTypes.StringType()"],"type":"node"}," for deserializing is:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["T(x::String)"],"type":"node"},": define a constructor for your type that takes a single String argument"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["StructTypes.construct(::Type{T}, x::String; kw...)"],"type":"node"},": alternatively, you may overload ",{"attributes":{},"tag":"code","children":["StructTypes.construct"],"type":"node"}," for your type"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["StructTypes.construct(::Type{T}, ptr::Ptr{UInt8}, len::Int; kw...)"],"type":"node"},": another option is to overload ",{"attributes":{},"tag":"code","children":["StructTypes.construct"],"type":"node"}," with pointer and length arguments, if it's possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both ",{"attributes":{},"tag":"code","children":["StructTypes.construct"],"type":"node"}," methods, since direct pointer/length deserialization may not be possible for some inputs"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The interface to satisfy for serializing is:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["Base.string(x::T)"],"type":"node"},": overload ",{"attributes":{},"tag":"code","children":["Base.string"],"type":"node"}," for your type to return a \"stringified\" value, or more specifically, that returns an ",{"attributes":{},"tag":"code","children":["AbstractString"],"type":"node"},", and should implement ",{"attributes":{},"tag":"code","children":["ncodeunits(x)"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["codeunit(x, i)"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}