{"attributes":{"kind":"function","backlinks":[],"methods":[{"symbol_id":"StructTypes.applyfield","module_id":"StructTypes","file":"StructTypes.jl","line":856,"signature":"(::Signature)"}],"package_id":"StructTypes@1.10.0","title":"applyfield","symbol_id":"StructTypes.applyfield","exported":false,"module_id":"StructTypes"},"tag":"documentation","children":[{"attributes":{"symbol":"StructTypes.applyfield","line":844,"module":"StructTypes","file":"StructTypes.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["StructTypes.applyfield(f, ::Type{T}, nm::Symbol) => Bool\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Convenience function for working with a ",{"attributes":{},"tag":"code","children":["StructTypes.Mutable"],"type":"node"}," object. For a given serialization name ",{"attributes":{},"tag":"code","children":["nm"],"type":"node"},", apply the function ",{"attributes":{},"tag":"code","children":["f(i, name, FT; kw...)"],"type":"node"}," to the field index ",{"attributes":{},"tag":"code","children":["i"],"type":"node"},", field name ",{"attributes":{},"tag":"code","children":["name"],"type":"node"},", field type ",{"attributes":{},"tag":"code","children":["FT"],"type":"node"},", and any keyword arguments ",{"attributes":{},"tag":"code","children":["kw"],"type":"node"}," defined in ",{"attributes":{},"tag":"code","children":["StructTypes.keywordargs"],"type":"node"},". Various StructType configurations are respected like keyword arguments, names, and exclusions. ",{"attributes":{},"tag":"code","children":["applyfield"],"type":"node"}," returns whether ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," was executed or not; if ",{"attributes":{},"tag":"code","children":["nm"],"type":"node"}," isn't a valid field name on ",{"attributes":{},"tag":"code","children":["x"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["false"],"type":"node"}," will be returned (important for applications where the input still needs to consume the field, like json parsing). Note that the input ",{"attributes":{},"tag":"code","children":["nm"],"type":"node"}," is treated as the serialization name, so any ",{"attributes":{},"tag":"code","children":["StructTypes.names"],"type":"node"}," mappings will be applied, and the function will be passed the Julia field name."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}