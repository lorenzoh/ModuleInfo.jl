{"attributes":{"kind":"function","backlinks":[],"methods":[{"symbol_id":"Scratch.track_scratch_access","module_id":"Scratch","file":"Scratch.jl","line":108,"signature":"(::Signature)"}],"package_id":"Scratch@1.1.1","title":"track_scratch_access","symbol_id":"Scratch.track_scratch_access","exported":false,"module_id":"Scratch"},"tag":"documentation","children":[{"attributes":{"symbol":"Scratch.track_scratch_access","line":87,"module":"Scratch","file":"Scratch.jl"},"tag":"docstring","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["track_scratch_access(pkg_uuid, scratch_path)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["We need to keep track of who is using which spaces, so we know when it is advisable to remove them during a GC.  We do this by attributing accesses of spaces to ",{"attributes":{},"tag":"code","children":["Project.toml"],"type":"node"}," files in much the same way that package versions themselves are logged upon install, only instead of having the project information implicitly available, we must rescue it out from the currently-active Pkg Env.  If we cannot do that, it is because someone is doing something weird like opening a space for a Pkg UUID that is not loadable, which we will simply not track; that space will be reaped after the appropriate time in an orphanage."],"type":"node"},{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["pkg_uuid"],"type":"node"}," is explicitly set to ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"},", this space is treated as belonging to the current project, or if that does not exist, the default global project located at ",{"attributes":{},"tag":"code","children":["Base.load_path_expand(\"@v#.#\")"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["While package and artifact access tracking can be done at ",{"attributes":{},"tag":"code","children":["add()"],"type":"node"},"/",{"attributes":{},"tag":"code","children":["instantiate()"],"type":"node"}," time, we must do it at access time for spaces, as we have no declarative list of spaces that a package may or may not access throughout its lifetime.  To avoid building up a ludicrously large number of accesses through programs that e.g. call ",{"attributes":{},"tag":"code","children":["get_scratch!()"],"type":"node"}," in a loop, we only write out usage information for each space once per day at most."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}